# ğŸ“¡ Airflow: Sensors

ğŸ” **Sensors wait** for a specific **event/condition** to be met before completing.

â³ **Default Timeout:**  
Sensors will **timeout after 7 days** unless you set a custom value using the `timeout` parameter.

â±ï¸ **Polling Frequency:**  
Sensors check the condition **every `poke_interval`** (â° default: **60 seconds**).

ğŸ’¼ **Resource Usage:**  
While waiting, a sensor **holds a worker slot**, which can lead to resource contention if many are used.

ğŸ§˜ **Use Reschedule Mode:**  
For long waits or many sensors, switch to `reschedule` mode:
- ğŸŸ¡ Status: `up_for_reschedule`
- âœ… Frees up worker slots while waiting!

ğŸ”§ **Define with Decorator:**  
You can create a sensor using the `@task.sensor` decorator.

## ğŸ§ª Example: File Sensor with Reschedule Mode

```python
from airflow.decorators import dag, task, task_sensor
from airflow.utils.dates import days_ago
import os

@dag(start_date=days_ago(1), schedule_interval=None, catchup=False)
def sensor_example_dag():

    @task_sensor(poke_interval=30, timeout=3600, mode="reschedule")
    def wait_for_file():
        filepath = "/tmp/data_ready.txt"
        return os.path.exists(filepath)

    @task
    def process_file():
        print("File found! Starting processing...")

    wait = wait_for_file()
    process_file() >> wait

sensor_example_dag()
```

ğŸ§¾ Explanation:
- ğŸ› ï¸ `@task_sensor`: Defines a sensor task using the decorator.
- â³ `timeout=3600`: Wait up to 1 hour for the file.
- â±ï¸ `poke_interval=30`: Check every 30 seconds.
- ğŸ§˜ `mode="reschedule"`: Releases the worker slot while waiting.
- ğŸ“‚ **Logic**: Waits until /tmp/data_ready.txt exists, then proceeds to the processing task.

